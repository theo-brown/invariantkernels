import itertools

import torch


def permutation_group(x: torch.Tensor) -> torch.tensor:
    """Generate all permutations of the last dimension of x.

    Parameters
    ----------
    x : torch.Tensor
        Input data. Shape is ``(n, d)`` or ``(b, n, d), where ``b`` is the batch size, ``n`` is the number of data points and ``d`` is the number of input dimensions.

    Returns
    -------
    torch.tensor
        All permutations of the last dimension of x. Shape is ``(G, n, d)``, where ``G`` is the number of permutations of the last dimension of x.
    """
    indices = range(x.size(-1))  # x is of shape n x d or b x n x d
    permuted_indices = [list(p) for p in itertools.permutations(indices)]
    if x.dim() == 2:
        x_orbits = x[:, permuted_indices]  # Shape is n x G x d
        return x_orbits.permute(1, 0, 2)  # Reorder the dimensions to G x n x d
    elif x.dim() == 3:
        x_orbits = x[:, :, permuted_indices]  # Shape is b x n x G x d
        return x_orbits.permute(2, 0, 1, 3)  # Reorder the dimensions to G x b x n x d
    else:
        raise ValueError(
            "Input x must have 2 or 3 dimensions (got {x.dim()} dimensions, shape {x.shape})."
        )


def block_permutation_group(x: torch.Tensor, block_size: int) -> torch.tensor:
    """Generate all block-permutations of the last dimension of x, in blocks of size block_size.

    Parameters
    ----------
    x : torch.Tensor
        Input data. Shape is ``(n, d)`` or ``(b, n, d), where ``b`` is the batch size, ``n`` is the number of data points and ``d`` is the number of input dimensions.
    block_size : int
        Size of the blocks to permute. Must be a divisor of the last dimension of x.

    Returns
    -------
    torch.tensor
        All block-permutations of the last dimension of x. Shape is ``(G, n, d)``, where ``G`` is the number of block-permutations of the last dimension of x.
    """
    if x.size(-1) % block_size != 0:
        raise ValueError(
            "Last dimension of x must be a multiple of block size"
            f" (got {x.size(-1)} and {block_size} respectively)."
        )

    block_indices = [range(i, i + block_size) for i in range(0, x.size(-1), block_size)]
    # Use itertools.chain to flatten the list of lists generated by the permutation
    permuted_indices = [
        list(itertools.chain.from_iterable(p))
        for p in itertools.permutations(block_indices)
    ]

    if x.dim() == 2:
        x_orbits = x[:, permuted_indices]  # Shape is n x G x d
        return x_orbits.permute(1, 0, 2)  # Reorder the dimensions to G x n x d
    elif x.dim() == 3:
        x_orbits = x[:, :, permuted_indices]  # Shape is b x n x G x d
        return x_orbits.permute(2, 0, 1, 3)  # Reorder the dimensions to G x b x n x d
    else:
        raise ValueError(
            "Input x must have 2 or 3 dimensions (got {x.dim()} dimensions, shape {x.shape})."
        )
